# **アジャイルソフトウェア開発の奥義**

## **第８章　単一責任の原則（SRP）**
SRP: The Single Responsibility Principle

**クラスを変更する理由は１つ以上存在してはならない。**  
  
　第6章のボウリングの例では、開発している間、Gameクラスはずっと2つの役割（責任） ―現在のフレームの状態記録とスコアの計算― を果たしていた。最後になって、この2つの役割を2つのクラスに分割することにした。Gameクラスはそのままフレームの状態を記録することにして、Scorerクラスがスコアの計算を担当することになったわけだ。  
　2つの役割を別々のクラスに分けるのが、なぜそんなに重要だったのだろう？役割が複数あれば、その1つ1つが変更理由になってしまうからだ。仕様要求が変わると、クラスの役割が変化するので、どのように変化したのかを見れば、変更部分が浮き彫りになる。しかし、クラスが複数の役割を背負ってしまうと、クラスを変更する理由も複数になってしまい、変更部分がぼやけてしまう。  
　クラスが複数の役割を背負っているような場合、それらの役割は結合してしまう。その結果、ある役割が変更を受けると、そのクラスが担っている他の役割も影響を受け、不具合が生じる可能性がある。こういったたぐいの結合は、ある部分が変更を受けると、予想もしない形で壊れてしまうような**もろい**設計を生み出してしまう。

### **8.1.1　役割とは何か？**
　単一責任の原則（SRP）では、「役割（責任）＝変更理由」と定義している。クラスを変更するのに2つ以上の理由がある場合、そのクラスには2つ以上の役割があることになる。しかし、クラスが2つ以上の役割を担っているかどうかを見極めるのは難しい。たとえば、リスト8-1に示すようなModemインタフェースを考えてみよう。ほとんどの人が、これが非常に合理的なインタフェースであることに同意するだろう。

```Java
リスト8-1: Modem.java ―― 単一責任の原則（SRP）違反

interface Modem
{
  public void dial(String pno);
  public void hangup();
  public void send(char c);
  public char recv();
}
```

　しかしながら、ここには2つの役割が記述されている。最初の役割は「接続の管理」であり、2つ目の役割は「データ通信」である。dial関数とhangup関数はモデムの接続を管理しており、send関数とrecv関数はデータを送受信している。  
　この2つの役割は分離すべきだろうか? それは、アプリケーションが今後どのように変更されるかどうか次第だ。接続承認プロセスを管理するような部分、つまり「接続を管理」する関数が影響を 受けるような変更がされる場合、この設計は「硬さ」 を露呈する。send関数とrecv関数を呼び出す クラスを不必要にリコンパイル、再ロードしなければならなくなるからだ。 このような変更を受けるケースでは、2つの役割は、図8-3に示すように分離すべきである。 こうしておけば、これらのインタフェースを利用するアプリケーションはそれぞれの役割を個別に利用できる。
　一方、2つの役割が必ず同時に変更されるようなケースでは、これらを分離する必要はない。 そうしてしまうと逆に、設計が**不必要に複雑**になってしまうことになる。  
　ここには必然的な法則がある。 「変更の理由が変更の理由たるのは、 実際に変更の理由が生じた場合だけである」という法則だ。変更の兆候もないのに単一責任の原則（SRP）を適用するのは賢明ではない。 これは、他の原則についても同様だ。

### **8.1.3　永続性のあるシステムと単一責任の原則（SRP）**

　図8-4 は典型的な単一責任の原則（SRP）違反の例である。 Employee（従業員）クラスがビジネス ルールと永続性のあるシステム（データベースなど）を包含してしまっている。この2つの役割は、絶対に混ぜてはいけない。ビジネスルールは頻繁に変化するものである。また、永続性のあるシステムはあまり変化しないものの、ビジネスルールの場合とはまったく違う理由で変化する場合がある。ビジネスルールと永続性のあるシステムを結合することは、自らトラブルに飛び込むようなものだ。

![](img/5a05dbb2.png)

　第4章で見たように、テスト主導の開発方法に従えば、設計に怪しい兆しが現れるはるか以前に、 ここで見たような2つの役割は分離されるだろう。しかしながら、テストがそういった分離を促さな いにもかかわらず「硬さ」や「もろさ」の兆しが現れた場合は、Facade パターンやProxyパターンを 使ってリファクタリングし、この2つの役割を分離すべきである。
